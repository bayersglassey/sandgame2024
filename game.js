'use strict';

var FRAMERATE = 15;
var LOG_KEYS = false;
var MAGIC = 'XXMAGICXX';

var TIME_UNITS_PER_DAY = 60 * 60 * 24;
var MIDNIGHT = 0;
var DAWN = TIME_UNITS_PER_DAY * (1 / 4);
var NOON = TIME_UNITS_PER_DAY * (2 / 4);
var SUNSET = TIME_UNITS_PER_DAY * (3 / 4);

var DEFAULT_PORTAL_WIDTH = 16;
var DEFAULT_PORTAL_HEIGHT = 16;

var DEFAULT_GAMEDATA = {
    width: 300,
    height: 200,
    zoom: 3,
    time: 0,
    people: [{}],
    portals: [],
};

// Key codes
function get_keycode(s) {
    // e.g.
    // 'a' -> 65
    // 'A' -> 65
    // 'B' -> 66
    // ...etc...
    return s.toUpperCase().charCodeAt(0);
}
var KEYCODE_SHIFT = 16;
var KEYCODE_CONTROL = 17;
var KEYCODE_UP = 38;
var KEYCODE_DOWN = 40;
var KEYCODE_LEFT = 37;
var KEYCODE_RIGHT = 39;
var KEYCODE_SPACE = 32;

var KEYMAP_1 = {
    [KEYCODE_UP]: 'u',
    [KEYCODE_DOWN]: 'd',
    [KEYCODE_LEFT]: 'l',
    [KEYCODE_RIGHT]: 'r',
    [KEYCODE_SPACE]: 'j',
};

var KEY_ROWS = [
    '1234567890',
    'qwertyuiop',
    'asdfghjkl',
    'zxcvbnm',
];

function create_material_elems() {
    // Generates DOM elements used by get_material_elem
    var materials_elem = document.getElementById('materials');
    for (var row of KEY_ROWS) {
        var div = document.createElement('div');
        materials_elem.appendChild(div);
        for (var key of row) {
            if (!(key in SELECT)) continue;
            var material = SELECT[key];
            var span = document.createElement('span');
            div.appendChild(span);
            span.id = 'material_' + material;
            span.setAttribute('data-material', material);
            span.className = 'material';
            span.textContent = key;
            span.style.background = css_material(material);
            span.onmousedown = function(event) {
                var span = event.target;
                var material = Number(span.getAttribute('data-material'));
                window.game.select_material(material);
            };
        }
    }
}

function get_material_elem(material) {
    // Returns an element generated by create_material_elems
    return document.getElementById('material_' + material);
}


function rgba(r, g, b, a) {
    var uint8 = new Uint8ClampedArray([r, g, b, a]);
    var uint32 = new Uint32Array(uint8.buffer);
    return uint32[0];
}


function rgb(r, g, b) {
    return rgba(r, g, b, 255);
}


function unpack_rgb(material) {
    var uint32 = new Uint32Array([material]);
    return new Uint8ClampedArray(uint32.buffer);
}


function css_rgb(r, g, b, a) {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb
    // Each value can be represented as a <number> between 0 and 255,
    // a <percentage> between 0% and 100%, or the keyword none
    // (equivalent to 0% in this case).
    if (a === undefined) a = 1;
    else a = a / 255;
    return `rgb(${r}, ${g}, ${b}, ${a})`;
}

function css_hsl(h, s, l, a) {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl
    // H: A <number>, an <angle>, or the keyword none (equivalent to
    // 0deg in this case) representing the color's <hue> angle.
    // S: A <percentage> or the keyword none (equivalent to 0% in this
    // case). This value represents the color's saturation. Here 100%
    // is completely saturated, while 0% is completely unsaturated (gray).
    // L: A <percentage> or the keyword none (equivalent to 0% in this
    // case). This value represents the color's lightness. Here 100%
    // is white, 0% is black, and 50% is "normal".
    if (a === undefined) a = 1;
    else a = a / 255;
    return `hsl(${h} ${s} ${l} /${a})`;
}

function css_material(material) {
    var rgba = unpack_rgb(material);
    return css_rgb(rgba[0], rgba[1], rgba[2], rgba[3]);
}


function get_portal_color(t) {
    function bounce(t) {
        var c = (t * 4) % 512;
        return (c >= 256)? 512 - c: c;
    }
    return rgb(bounce(t), bounce(t + 100), bounce(t + 200));
}


function draw_rect(pixels, width, x0, y0, w, h, c) {
    // NOTE: pixels is a Uint32Array

    var height = pixels.length / width;

    var x1 = x0 + w;
    var y1 = y0 + h;

    // These are used in the for-loops
    var _x0 = x0, _y0 = y0, _x1 = x1, _y1 = y1;
    if (_x0 < 0) _x0 = 0;
    else if (_x0 >= width) _x0 = width - 1;
    if (_y0 < 0) _y0 = 0;
    else if (_y0 >= height) _y0 = height - 1;
    if (_x1 < 0) _x1 = 0;
    else if (_x1 >= width) _x1 = width - 1;
    if (_y1 < 0) _y1 = 0;
    else if (_y1 >= height) _y1 = height - 1;

    // Top
    if (y0 >= 0 && y0 < height) {
        var i = y0 * width;
        for (var x = _x0; x <= _x1; x++) pixels[i + x] = c;
    }

    // Bottom
    if (y1 >= 0 && y1 < height) {
        var i = y1 * width;
        for (var x = _x0; x <= _x1; x++) pixels[i + x] = c;
    }

    // Left
    if (x0 >= 0 && x0 < width) {
        var i0 = (_y0 + 1) * width + x0;
        var i1 = (_y1 - 1) * width + x0;
        for (var i = i0; i <= i1; i += width) pixels[i] = c;
    }

    // Right
    if (x1 >= 0 && x1 < width) {
        var i0 = (_y0 + 1) * width + x1;
        var i1 = (_y1 - 1) * width + x1;
        for (var i = i0; i <= i1; i += width) pixels[i] = c;
    }
}


function rect_collide(ax0, ay0, aw, ah, bx0, by0, bw, bh) {
    var ax1 = ax0 + aw;
    var ay1 = ay0 + ah;
    var bx1 = bx0 + bw;
    var by1 = by0 + bh;
    return (
        ax1 >= bx0 && bx1 >= ax0 &&
        ay1 >= by0 && by1 >= ay0
    );
}

function shuffle(items) {
    // Randomly shuffle the given array
    // Based on: https://stackoverflow.com/a/12646864
    for (var i = items.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }
}


var NOTHING = 0;
var SAND = rgb(170, 130, 70);
var STONE = rgb(120, 120, 120);
var WATER = rgb(20, 80, 255);
var OIL = rgb(20, 180, 200);
var SANDSPOUT = rgb(120, 80, 20);
var WATERSPOUT = rgb(0, 30, 205);
var OILSPOUT = rgb(0, 130, 150);
var HOLE = rgb(60, 60, 60);
var SKIN = rgb(255, 150, 180);
var CLOTHES = rgb(120, 80, 40);
var WOOD = rgb(255, 125, 125);
var DENSITY = {
    [NOTHING]: 0,
    [SAND]: 3,
    [WATER]: 2,
    [OIL]: 1,
    [STONE]: 99,
    [SANDSPOUT]: 99,
    [WATERSPOUT]: 99,
    [OILSPOUT]: 99,
    [HOLE]: 3,
    [WOOD]: 3,
};
var SELECT = {
    0: NOTHING,
    1: SAND,
    2: WATER,
    3: STONE,
    4: OIL,
    5: WOOD,

    q: SANDSPOUT,
    w: WATERSPOUT,
    e: HOLE,
    r: OILSPOUT,
};
var SOLID = [SAND, STONE, SANDSPOUT, WATERSPOUT, OILSPOUT, HOLE, SKIN, CLOTHES, WOOD];
var FALLS = [SAND, WATER, OIL, HOLE, WOOD];
var FALLS_STRAIGHT = [WOOD];
var SUPPORTS = {
    [WOOD]: [WOOD],
};
var FLUID = [WATER, OIL];
var PUSHABLE = [SAND, WOOD];
var SPOUTS = {
    [SANDSPOUT]: SAND,
    [WATERSPOUT]: WATER,
    [OILSPOUT]: OIL,
};
var EATS = {
    [HOLE]: [SAND, WATER, OIL, HOLE],
};


function get_density(material) {
    var density = DENSITY[material];
    if (density === undefined) return 10;
    return density;
}

function eats(material1, material2) {
    var eats_materials = EATS[material1];
    if (!eats_materials) return false;
    return eats_materials.indexOf(material2) >= 0;
}

function is_denser(material1, material2) {
    return get_density(material1) > get_density(material2);
}

function is_denser_or_equal(material1, material2) {
    return get_density(material1) >= get_density(material2);
}

function is_solid(material) {
    return SOLID.indexOf(material) >= 0;
}

function does_fall(material) {
    return FALLS.indexOf(material) >= 0;
}

function does_fall_straight(material) {
    return FALLS_STRAIGHT.indexOf(material) >= 0;
}

function supports(material1, material2) {
    var supports_materials = SUPPORTS[material1];
    if (!supports_materials) return false;
    return supports_materials.indexOf(material2) >= 0;
}

function is_fluid(material) {
    return FLUID.indexOf(material) >= 0;
}

function is_pushable(material) {
    return PUSHABLE.indexOf(material) >= 0;
}

function deserialize(obj, data) {
    // Copy keys of data onto obj

    if (obj === null || typeof obj !== 'object') return;
    if (Array.isArray(obj)) return; // we dunno how to populate arrays

    // If we get this far, obj is an object, like a custom class instance
    for (var key of obj.SERIALIZE_FIELDS) {
        if (!(key in data)) continue;
        var value = data[key];
        if (Array.isArray(value)) continue; // we dunno how to populate arrays
        obj[key] = value;
    }
}

function serialize(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (Array.isArray(obj)) return obj.map(serialize);

    // If we get this far, obj is an object, like a custom class instance
    var data = {};
    for (var key of obj.SERIALIZE_FIELDS) {
        data[key] = serialize(obj[key]);
    }
    return data;
}


class Person {
    KEYS = 'udlrj';
    JUMP = 25;
    JUMP_HANG = 5;

    SERIALIZE_FIELDS = ['x', 'y', 'jump', 'width', 'height'];

    constructor(game, keymap) {
        this.game = game;
        this.keymap = keymap;

        this.x = Math.round(game.width / 2);
        this.y = Math.round(game.height - 1);
        this.jump = 0;
        this.jump_released = true;
        this.width = 1;
        this.height = 3;

        this.keydown = {};
        for (var key of this.KEYS) this.keydown[key] = false;
    }

    step() {
        var on_ground = this.collide(0, 1);
        if (this.keydown.l && !this.keydown.r) this.move_x(-1);
        if (this.keydown.r && !this.keydown.l) this.move_x(1);
        if (this.keydown.j) {
            if (this.jump) {
                // We're holding jump, and already jumping
                if (this.jump > this.JUMP_HANG) this.move_y(-1);
                this.jump--;
            } else if (on_ground && this.jump_released) {
                // We're holding jump, and on the ground, and we stopped
                // holding jump at some point since the last jump
                this.jump = this.JUMP;
                this.jump_released = false;
                this.move_y(-1);
            } else {
                // We're holding jump, and falling
                this.move_y(1);
            }
        } else {
            // We're not holding jump
            this.jump_released = true;
            if (this.jump > this.JUMP_HANG) {
                // We were moving upwards; now let's hang in mid-air for a bit
                this.jump = this.JUMP_HANG;
            } else if (this.jump) {
                // We're hanging in mid-air for a bit
                this.jump--;
            } else {
                // We're falling (or standing on ground)
                this.move_y(1);
            }
        }

        for (var portal of this.game.portals) {
            if (!portal.image_url) continue;
            if (!rect_collide(
                this.x, this.y - (this.height - 1), this.width, this.height,
                portal.x, portal.y, portal.width, portal.height,
            )) continue;
            this.game.portal_activated = true;
            new_game_from_image(portal.image_url);
        }
    }

    collide(dx, dy) {
        // Check whether we would collide with anything solid if our x, y
        // were moved by dx, dy

        var width = this.game.width;
        var height = this.game.height;

        var x = this.x + dx;
        if (x < 0 || x >= width) return true;

        var pixels = this.game.pixels;

        var y0 = this.y - (this.height - 1) + dy;
        var y1 = this.y + dy;
        for (var y = y0; y <= y1; y++) {
            if (
                x === this.x &&
                y >= this.y - (this.height - 1) &&
                y <= this.y
            ) {
                // Make sure we don't collide with ourselves!..
                continue;
            }
            if (y < 0 || y >= height) return true;
            var i = y * width + x;
            if (is_solid(pixels[i])) return true;
        }
        return false;
    }

    move_x(dx) {

        // Attempt to walk 1 pixel left/right, moving up any inclines
        // less high than we are
        var dy0 = 0;
        var dy1 = -(this.height - 1);
        if (this.keydown.d) dy1 = 0;
        for (var dy = dy0; dy >= dy1; dy--) {
            if (this.collide(dx, dy)) continue;

            // We can move!
            var x = this.x;
            var y0 = this.y - (this.height - 1);
            var y1 = this.y;
            for (var y = y0; y <= y1; y++) {
                this.game.swap_pixel(x, y, x + dx, y + dy);
            }
            this.x += dx;
            this.y += dy;
            return;
        }

        // We couldn't move forwards normally, so let's attempt to push
        // whatever's in front of us
        this.push_x(dx);
    }

    push_x(dx) {
        var y0 = this.y;
        var y1 = this.y - (this.height - 1);
        for (var y = y0; y >= y1; y--) {
            var x0 = this.x + dx;
            var prev_pixel;
            var pixel = NOTHING;
            for (
                var x = x0;
                (
                    prev_pixel = pixel,
                    pixel = this.game.get_pixel(x, y),
                    get_density(pixel) > 0 && (
                        is_pushable(pixel) ||
                        is_denser_or_equal(prev_pixel, pixel)
                    )
                );
                x += dx
            );
            if (get_density(pixel) > 0) continue;
            var x1 = x;
            for (var x = x1; x !== x0; x -= dx) {
                this.game.swap_pixel(x, y, x - dx, y);
            }
        }
    }

    move_y(dy) {
        // Attempt to move 1 pixel up/down

        // Try to push stuff away from on top of us
        if (dy < 0) this.push_y(dy);

        if (this.collide(0, dy)) return;

        var dx = 0;
        var x = this.x;
        if (dy < 0) {
            var y0 = this.y - (this.height - 1);
            var y1 = this.y;
            for (var y = y0; y <= y1; y++) {
                this.game.swap_pixel(x, y, x + dx, y + dy);
            }
        } else {
            var y0 = this.y;
            var y1 = this.y - (this.height - 1);
            for (var y = y0; y >= y1; y--) {
                this.game.swap_pixel(x, y, x + dx, y + dy);
            }
        }

        this.y += dy;
    }

    push_y(dy) {
        var x = this.x;

        var y0 = this.y + dy;
        if (dy < 0) y0 -= this.height - 1;

        var prev_pixel;
        var pixel = NOTHING;
        for (
            var y = y0;
            (
                prev_pixel = pixel,
                pixel = this.game.get_pixel(x, y),
                get_density(pixel) > 0 && (
                    is_pushable(pixel) ||
                    is_denser_or_equal(prev_pixel, pixel)
                )
            );
            y += dy
        );
        if (get_density(pixel) > 0) return;
        var y1 = y;
        for (var y = y1; y !== y0; y -= dy) {
            this.game.swap_pixel(x, y, x, y - dy);
        }
    }

    onkeydown(keycode) {
        var keyname = this.keymap[keycode];
        if (keyname) this.keydown[keyname] = true;
    }

    onkeyup(keycode) {
        var keyname = this.keymap[keycode];
        if (keyname) this.keydown[keyname] = false;
    }

    render_pixels() {
        this._render_pixels();
    }
    clear_pixels() {
        this._render_pixels(true);
    }
    _render_pixels(clear) {
        var width = this.game.width;
        var height = this.game.height;

        var x = this.x;
        if (x < 0 || x >= width) return;

        var pixels = this.game.pixels;

        var y0 = this.y - (this.height - 1);
        var y1 = this.y;
        for (var y = y0; y <= y1; y++) {
            if (y < 0 || y >= height) continue;
            var i = y * width + x;
            pixels[i] = clear? NOTHING: y === y0? SKIN: CLOTHES;
        }
    }
}


class Portal {
    SERIALIZE_FIELDS = ['x', 'y', 'width', 'height', 'image_url'];

    constructor(x, y, width, height, image_url) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.image_url = image_url || null;
    }
}


class SandGame {
    SERIALIZE_FIELDS = ['width', 'height', 'zoom',
        'people', 'portals', 'time'];

    constructor(canvas, pixels, gamedata, image_url) {
        gamedata = gamedata || {};

        // Get default values for gamedata fields
        for (var key of this.SERIALIZE_FIELDS) {
            if (key in gamedata) continue;
            gamedata[key] = DEFAULT_GAMEDATA[key];
        }

        var width = gamedata.width;
        var height = gamedata.height;
        var zoom = gamedata.zoom;

        // NOTE: pixels is an optional Uint32Array
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this.zoom = zoom;
        this.image_url = image_url || null;
        this.time = gamedata.time;
        this.timeout_handle = null;

        if (!pixels) {
            this.pixels = new Uint32Array(width * height);
            this.pixels.fill(NOTHING);
        } else {
            this.pixels = pixels;
        }

        this.keydown = {};
        this.mousedown = false;
        this.mouse_x = 0;
        this.mouse_y = 0;

        this.selected_material = null;
        this.adding_portal = false;
        this.moving_person = false;
        this.select_material(SAND);

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = width * zoom;
        canvas.style.height = height * zoom;
        window.addEventListener('keydown', this.onkeydown.bind(this));
        window.addEventListener('keyup', this.onkeyup.bind(this));
        canvas.addEventListener('mousedown', this.onmousedown.bind(this));
        window.addEventListener('mouseup', this.onmouseup.bind(this));
        canvas.addEventListener('mousemove', this.onmousemove.bind(this));

        // We will randomly shuffle this array each step, and use it to
        // decide in what order to process pixels
        this.indexes = [];
        for (var i = 0; i < width * height; i++) this.indexes[i] = i;

        this.people = [];
        for (var person_gamedata of gamedata.people) {
            var keymap = KEYMAP_1; // TODO: add more keymaps, or AI, or whatever
            var person = new Person(this, keymap);
            this.people.push(person);
            deserialize(person, person_gamedata);
        }

        // When we touch a portal, we need to load a new level, but loading
        // is an async operation, so we need a way to make sure we don't
        // trigger another load while waiting for the first one to finish.
        // So, we set this to true, and it causes the game to be paused
        // until the load completes.
        this.portal_activated = false;

        this.portals = [];
        for (var portal_gamedata of gamedata.portals) {
            this.add_portal(
                portal_gamedata.x,
                portal_gamedata.y,
                portal_gamedata.width,
                portal_gamedata.height,
                portal_gamedata.image_url,
            );
        }
    }

    add_portal(x, y, width, height, image_url) {
        // wtf, javascript
        if (x === undefined) throw new Error("x undefined");
        if (y === undefined) throw new Error("y undefined");
        if (width === undefined) throw new Error("width undefined");
        if (height === undefined) throw new Error("height undefined");
        var portal = new Portal(x, y, width, height, image_url);
        this.portals.push(portal);
    }

    select_material(material) {
        this.adding_portal = false;
        this.moving_person = false;
        if (this.selected_material !== null) {
            var elem = get_material_elem(this.selected_material);
            elem.classList.remove('selected');
        }
        if (material !== null) {
            var elem = get_material_elem(material);
            elem.classList.add('selected');
        }
        this.selected_material = material;
    }

    onkeydown(event) {
        if (LOG_KEYS) {
            console.log('keydown', event.keyCode);
        }
        this.keydown[event.keyCode] = true;

        // Key is in 0-9 or a-z
        var key = event.key.toLowerCase()
        if (key in SELECT) {
            this.select_material(SELECT[key]);
        }

        for (var person of this.people) person.onkeydown(event.keyCode);
    }
    onkeyup(event) {
        this.keydown[event.keyCode] = false;
        for (var person of this.people) person.onkeyup(event.keyCode);
    }
    onmousedown(event) {
        if (event.button !== 0) return;
        this.set_mouse(event);
        if (this.adding_portal) {
            var portal_image_input = document.getElementById('portal_image_input');
            var image_url = portal_image_input.value || null;
            var w = DEFAULT_PORTAL_WIDTH;
            var h = DEFAULT_PORTAL_HEIGHT;
            this.add_portal(
                this.mouse_x - Math.floor(w / 2),
                this.mouse_y - Math.floor(h / 2),
                w, h, image_url);
            this.adding_portal = false;
        } else if (this.moving_person) {
            if (
                this.mouse_x >= 0 && this.mouse_x < this.width &&
                this.mouse_y >= 0 && this.mouse_y < this.height
            ) {
                var person = this.people[0];
                person.clear_pixels();
                person.x = this.mouse_x;
                person.y = this.mouse_y;
                this.moving_person = false;
            }
        } else {
            this.mousedown = true;
            this.dropstuff();
        }
    }
    onmouseup(event) {
        if (event.button !== 0) return;
        this.mousedown = false;
    }
    onmousemove(event) {
        this.set_mouse(event);
        if (this.mousedown) this.dropstuff();
    }
    set_mouse(event) {
        this.mouse_x = Math.floor(event.offsetX / this.zoom);
        this.mouse_y = Math.floor(event.offsetY / this.zoom);
    }

    dropstuff() {
        var mx = this.mouse_x, x0 = mx, x1 = mx;
        var my = this.mouse_y, y0 = my, y1 = my;

        if (!this.keydown[KEYCODE_CONTROL]) {
            x0 -= 3;
            x1 += 3;
        }

        for (var x = x0; x <= x1; x++) {
            for (var y = y0; y <= y1; y++) {
                if (
                    this.selected_material === NOTHING ||
                    this.keydown[KEYCODE_SHIFT] ||
                    get_density(this.get_pixel(x, y)) === 0
                ) {
                    this.set_pixel(x, y, this.selected_material);
                }
            }
        }

        this.render();
    }

    get_pixel(x, y) {
        if (x < 0 || x >= this.width) return STONE;
        if (y < 0 || y >= this.height) return STONE;
        var i = y * this.width + x;
        return this.pixels[i];
    }

    set_pixel(x, y, value) {
        if (x < 0 || x >= this.width) return;
        if (y < 0 || y >= this.height) return;
        var i = y * this.width + x;
        this.pixels[i] = value;
    }

    swap_pixel(x0, y0, x1, y1) {
        var pixel0 = this.get_pixel(x0, y0);
        var pixel1 = this.get_pixel(x1, y1);
        this.set_pixel(x0, y0, pixel1);
        this.set_pixel(x1, y1, pixel0);
    }

    render() {
        // Render people to this.pixels
        for (var person of this.people) person.render_pixels();

        // Create a copy of this.pixels, so we can draw more stuff
        // without affecting our particular simulation
        var pixels = this.pixels.slice();

        // Render portals to pixels
        var portal_color = get_portal_color(this.time);
        for (var portal of this.portals) {
            draw_rect(pixels, this.width,
                portal.x, portal.y, portal.width, portal.height,
                portal_color);
        }

        // Draw pixels onto canvas
        var pixel_data = new Uint8ClampedArray(pixels.buffer);
        var data = new ImageData(pixel_data, this.width, this.height);
        var ctx = this.canvas.getContext('2d');
        ctx.putImageData(data, 0, 0);
    }

    move_pixel(x0, y0, x1, y1) {
        var pixel0 = this.get_pixel(x0, y0);
        var pixel1 = this.get_pixel(x1, y1);
        if (eats(pixel1, pixel0)) {
            this.set_pixel(x0, y0, NOTHING);
            return true;
        } else if (is_denser(pixel0, pixel1)) {
            // Equivalent to: this.swap_pixel(x0, y0, x1, y1)
            this.set_pixel(x0, y0, pixel1);
            this.set_pixel(x1, y1, pixel0);
            return true;
        } else {
            return false;
        }
    }

    step() {
        if (this.portal_activated) return;

        if (this.mousedown) { this.dropstuff(); }

        // Tick... tick... tick...
        this.time = (this.time + 1) % TIME_UNITS_PER_DAY;

        // Game physics!
        shuffle(this.indexes);
        for (var i of this.indexes) {
            var x = i % this.width;
            var y = Math.floor(i / this.width);
            var material = this.pixels[i];

            // Falling physics
            if (does_fall(material)) {
                var supported = (
                    (
                        supports(this.get_pixel(x - 1, y), material) &&
                        supports(this.get_pixel(x + 1, y), material)
                    ) ||
                    supports(this.get_pixel(x - 1, y - 1), material) ||
                    supports(this.get_pixel(x + 1, y - 1), material)
                );
                if (supported) {
                    // Don't fall!
                } else if (this.move_pixel(x, y, x, y + 1)) {
                    // We fell straight down
                } else if (!does_fall_straight(material)) {
                    if (Math.random() < .5) {
                        if (this.move_pixel(x, y, x - 1, y + 1)) {
                            // We fell down and to the left
                        }
                    } else {
                        if (this.move_pixel(x, y, x + 1, y + 1)) {
                            // We fell down and to the right
                        }
                    }
                }
            }

            // Don't do anything more with this pixel if it moved!
            if (this.pixels[i] !== material) continue;

            // Fluid physics
            if (is_fluid(material)) {
                // Fluids randomly jiggle back and forth...
                if (Math.random() < .5) {
                    if (this.move_pixel(x, y, x - 1, y)) {
                        // We jiggled to the left
                    }
                } else {
                    if (this.move_pixel(x, y, x + 1, y)) {
                        // We jiggled to the right
                    }
                }
            }

            // Don't do anything more with this pixel if it moved!
            if (this.pixels[i] !== material) continue;

            // Spouting physics
            if (SPOUTS[material] && Math.random() < .05) {
                var spouted_material = SPOUTS[material];
                if (is_denser(spouted_material, this.get_pixel(x, y + 1))) {
                    // We spout straight down
                    this.set_pixel(x, y + 1, spouted_material);
                } else {
                    if (Math.random() < .5) {
                        if (is_denser(spouted_material, this.get_pixel(x - 1, y + 1))) {
                            // We spout down and to the left
                            this.set_pixel(x - 1, y + 1, spouted_material);
                        }
                    } else {
                        if (is_denser(spouted_material, this.get_pixel(x + 1, y + 1))) {
                            // We spout down and to the right
                            this.set_pixel(x + 1, y + 1, spouted_material);
                        }
                    }
                }
            }
        }

        // Person physics!
        for (var person of this.people) person.step();

        // Render and continue!
        this.render();
        this.timeout_handle = setTimeout(this.step.bind(this), FRAMERATE);
    }

    stop() {
        if (this.timeout_handle !== null) {
            clearTimeout(this.timeout_handle);
            this.timeout_handle = null;
        }
    }

    start() {
        if (this.timeout_handle === null) this.step();
    }

    is_running() {
        return this.timeout_handle !== null;
    }

    restart() {
        if (this.image_url) new_game_from_image(this.image_url);
        else new_game();
    }
}


window.addEventListener('load', function() {
    var canvas = document.getElementById('canvas');
    var filename_input = document.getElementById('filename_input');
    var save_btn = document.getElementById('save_btn');
    var load_btn = document.getElementById('load_btn');
    var load_level_btn = document.getElementById('load_level_btn');
    var new_game_btn = document.getElementById('new_game_btn');
    var pause_btn = document.getElementById('pause_btn');
    var restart_btn = document.getElementById('restart_btn');
    var add_portal_btn = document.getElementById('add_portal_btn');
    var move_person_btn = document.getElementById('move_person_btn');

    create_material_elems();

    window.addEventListener('keydown', function(event) {
        // Prevent spacebar or arrow keys from scrolling the damn page
        // Based on:
        // * https://stackoverflow.com/a/22559917
        // * https://stackoverflow.com/a/8916697
        var keyCode = event.keyCode;
        if(
            (
                keyCode === KEYCODE_SPACE ||
                keyCode === KEYCODE_DOWN ||
                keyCode === KEYCODE_UP)
            && (
                event.target === document.body ||
                event.target === window ||
                event.target === canvas
            )
        ) {
            event.preventDefault();
        }
    });

    function new_game(pixels, gamedata, image_url) {
        // NOTE: pixels is an optional Uint32Array, gamedata is an
        // optional Object, see DEFAULT_GAMEDATA, serialize, deserialize
        canvas.focus();

        var old_game = window.game;
        var paused = old_game && !old_game.is_running();
        if (old_game) old_game.stop();

        var game = new SandGame(canvas, pixels, gamedata, image_url);
        window.game = game;

        if (!paused) game.step();
        else game.render();
    }

    window.new_game = new_game;
    new_game();

    save_btn.onclick = function() {
        canvas.focus();
        var filename = filename_input.value + '.png';
        if (!filename) return;
        var data_url = canvas.toDataURL();
        var data_url_parts = data_url.split(',');
        var data = atob(data_url_parts[1]);
        data += MAGIC + JSON.stringify(serialize(window.game));
        data_url_parts[1] = btoa(data);
        data_url = data_url_parts.join(',');

        var link = document.createElement('a');
        document.body.appendChild(link);
        link.href = data_url;
        link.download = filename;
        link.click();
        link.remove();
    };

    load_btn.onclick = function() {
        canvas.focus();
        var filename = filename_input.value;
        if (!filename) return;
        new_game_from_image('images/' + filename + '.png');
    };

    load_level_btn.onclick = function() {
        canvas.focus();
        var filename = filename_input.value;
        if (!filename) return;
        new_game_from_image('levels/' + filename + '.png');
    };

    new_game_btn.onclick = function() {
        canvas.focus();
        new_game();
    };

    function new_game_from_image(image_url) {
        // CACHE BUST WHOOOOO
        var timestamp = Number(new Date());
        image_url += '?cache_bust=' + timestamp;

        var image = new Image();
        image.crossOrigin = 'Anonymous';
        image.onload = function() {
            var canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);
            var image_data = ctx.getImageData(0, 0, image.width, image.height);
            var pixels = new Uint32Array(image_data.data.buffer);

            // We now reload the same image we just loaded by setting
            // image.src, but this time we want to get at the raw data,
            // so we can grab some JSON we've left after the PNG data.
            // Wheeee!..
            fetch(image_url)
            .then(res => res.arrayBuffer())
            .then(buffer => {
                // Unlike image_data.buffer, which contains pixel data parsed
                // from the raw PNG data by the Image and <canvas>, the buffer
                // variable here contains raw PNG data (to which we have
                // appended some JSON, with a magic byte sequence, MAGIC,
                // separating the PNG data from the JSON data).
                var gamedata = JSON.parse(new TextDecoder('ascii')
                    .decode(buffer).split(MAGIC)[1]);
                console.log("Loaded game data", gamedata);
                new_game(pixels, gamedata, image_url);
            });
        }
        image.onerror = function(event) {
            console.log("Error loading image: " + image_url);
        }
        image.src = image_url;
    }

    window.new_game_from_image = new_game_from_image;

    function pause() {
        game.stop();
        pause_btn.textContent = 'UNPAUSE';
    }
    function unpause() {
        game.start();
        pause_btn.textContent = 'PAUSE';
    }

    pause_btn.onclick = function() {
        canvas.focus();
        if (game.is_running()) {
            pause();
        } else {
            unpause();
        }
    };

    restart_btn.onclick = function() {
        canvas.focus();
        game.restart();
    };

    add_portal_btn.onclick = function() {
        canvas.focus();
        game.select_material(null);
        game.adding_portal = true;
    }

    move_person_btn.onclick = function() {
        canvas.focus();
        game.select_material(null);
        game.moving_person = true;
    }
});
